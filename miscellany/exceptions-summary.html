<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Summary of papers about interrupts &mdash; Coreblocks documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
        <script>mermaid.initialize({startOnLoad:true});</script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="API" href="../api.html" />
    <link rel="prev" title="Instruction Cache" href="../components/icache.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Coreblocks documentation
            <img src="../_static/logo-banner.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../home.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../assumptions.html">List of assumptions made during development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development-environment.html">Development environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/overview.html">Scheduler overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../shared-structs/implementation/rs-impl.html">Proposition of Reservation Station implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../shared-structs/rs.html">Reservation Station</a></li>
<li class="toctree-l1"><a class="reference internal" href="../current-graph.html">Full transaction-method graph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../problem-checklist.html">Problem checklist</a></li>
<li class="toctree-l1"><a class="reference internal" href="../synthesis/synthesis.html">Core verification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../components/icache.html">Instruction Cache</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Summary of papers about interrupts</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#interrupt-handling-in-old-pcs">Interrupt handling in old PCs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#interrupt-handling-for-out-of-order-execution-processors">Interrupt Handling for Out-of-Order Execution Processors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#in-line-interrupt-handling-for-software-managed-tlbs">In-Line Interrupt Handling for Software-Managed TLBs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hardware-software-cost-analysis-of-interrupt-processing-strategies">Hardware/software cost analysis of interrupt processing strategies:</a></li>
<li class="toctree-l2"><a class="reference internal" href="#igpu-exception-support-and-speculative-execution-on-gpus">iGPU: Exception Support and Speculative Execution on GPUs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#efficient-exception-handling-support-for-gpus">Efficient Exception Handling Support for GPUs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#others">Others</a></li>
<li class="toctree-l2"><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coreblocks documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Summary of papers about interrupts</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/miscellany/exceptions-summary.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="summary-of-papers-about-interrupts">
<h1>Summary of papers about interrupts<a class="headerlink" href="#summary-of-papers-about-interrupts" title="Permalink to this heading"></a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading"></a></h2>
<p>This summary is a result of analysis of journal articles which I made as a preparation to implement support for
interrupts, exceptions and speculation to core blocks. It looks like the choice of primary interrupts related to
structure determines the interrupt handling procedure. We have chosen a ROB, so there is a one classical implementation
of the ROB interrupt handling procedure. This procedure is used as a basis for the improvements, but most of the papers
are pretty old (1993-2001). Currently there is no much research going on about CPU interrupt handling and it is
considered that this problem is solved. Instead of that, there are some works, which try to implement precise interrupts
on GPUs, but due to different characteristics of the CPU and GPU, this research can not be applied in an easy way to our
project.</p>
<p>When I have prepared this overview, I have decided to look at articles from different times to check on what people were
working at that time. So there is probably a lot of other works which can be worth checking out. Specifically:</p>
<ul class="simple">
<li><p>W. Walker and H. G. Cragon. “Interrupt processing in concurrent processors.” IEEE Computer, vol. 28, no. 6, June 1995</p></li>
<li><p>M. Moudgill and S. Vassiliadis. “Precise interrupts.” IEEE Micro, vol. 16, no. 1, pp. 58–67, February 1996
These two works present a survey of the topic of interrupts as a time of writing.</p></li>
</ul>
</div>
<div class="section" id="interrupt-handling-in-old-pcs">
<h2>Interrupt handling in old PCs<a class="headerlink" href="#interrupt-handling-in-old-pcs" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li><p>CDC 6600 - interrupt handling is done by inserting a jump instruction into the interrupt handler</p></li>
<li><p>IBM360 - stop fetching and wait for all fetched instructions to be committed, then jump to interrupt handler</p></li>
<li><p>CRAY-1 - similar to IBM360, but here latency can be even bigger due to vector instructions</p></li>
</ul>
</div>
<div class="section" id="interrupt-handling-for-out-of-order-execution-processors">
<h2>Interrupt Handling for Out-of-Order Execution Processors<a class="headerlink" href="#interrupt-handling-for-out-of-order-execution-processors" title="Permalink to this heading"></a></h2>
<blockquote>
<div><p>Interrupt Handling for Out-of-Order Execution Processors
H. C. Torng and Martin Day, 1993</p>
</div></blockquote>
<p>This article describes one of the first probes for the implementation of exceptions in out-of-order processes. In that
time, ROB was a very new idea. The authors of this paper introduced Instruction Window (IW) as their proposition for the
implementation of interrupts in out-of-order processors. IW will store all dispatched instructions, which didn’t
complete. In the case of an interrupt it will be a part of the context and will be copied to memory by the interrupt handler.
After restoring the context, all instructions from IW will be restarted so that the state of the CPU will be precise.</p>
<p>The idea of IW is similar to that of ROB, but there are few differences:</p>
<ul class="simple">
<li><p>ROB is not a part of the context</p></li>
<li><p>ROB removes instructions in-order, IW allows to remove instructions out-of-order</p></li>
<li><p>Tags in IW are one-hot-encoded, which will in current implementation cause big overhead.</p></li>
</ul>
<p>So in its original form, IW is unfeasible for our processor, because it would require to double a job. Additionally,
this context of the ROB size will have to be stored on each entry to the interrupt handler, which can be costly
operations. But:</p>
<ul class="simple">
<li><p>maybe it is possible to reduce cost of IW saving by cooperation of CPU and OS?</p></li>
<li><p>maybe cost of restoring IW is smaller than cost of re-fetching and scheduling one more time for old instructions?</p></li>
</ul>
<p>Some interesting ideas from the paper:</p>
<ul class="simple">
<li><p>they propose NRP (No Return Point) implementation - a point in the pipeline after which an instruction can be removed,
it should allow instructions which are ending to save its results and remove itself from IW, to don’t waste cycles on
context restore for executing this instruction one more time, NRP can be implemented for different interrupts and
instructions in different places to allow different interrupt latency</p></li>
<li><p>for vector instructions IW remember how many elements are left to be processed, so after this context restore allows
to restore vector operation in the middle of the vector</p></li>
</ul>
</div>
<div class="section" id="in-line-interrupt-handling-for-software-managed-tlbs">
<h2>In-Line Interrupt Handling for Software-Managed TLBs<a class="headerlink" href="#in-line-interrupt-handling-for-software-managed-tlbs" title="Permalink to this heading"></a></h2>
<blockquote>
<div><p>In-Line Interrupt Handling for Software-Managed TLBs
Aamer Jaleel and Bruce Jacob, 2001</p>
</div></blockquote>
<p>In that time, ROB was already a standard, so there was “classic” interrupt handling procedure. But in that time
there is still a lot of software managed TLBs, which cause an interrupt on each page miss. This of course causes a big
context switch overhead, so the authors of this paper try to reduce this penalty. As a base architecture they use Alpha and MIPS. They
concentrate on improving TLB miss efficiency and this has a property that interrupt handlers are very short (10-30
instructions).</p>
<p>The main idea is to not flush the whole pipeline on an interrupt, but instead to inline a handler code between
instructions of the user space program. They observed that the most important problem is that there can not be enough
resources to execute the interrupt handler without flushing the pipeline (e.g. in case when ROB is full there can be
live-lock).</p>
<ul class="simple">
<li><p>they assume that interrupt handler has known length</p></li>
<li><p>they check if ROB, RS and RF have enough free resources to inline handler</p></li>
<li><p>if the handler can be inlined, they do that, else they flush the pipeline</p></li>
<li><p>in fly instruction return instruction is swapped to NOP and excepted instruction is reexecuted</p></li>
<li><p>each executed instruction has one connected bit indicating the privilege level</p></li>
</ul>
<p>They use some properties of the Alpha and MIPS architectures where they have interrupts vectors so the OS can insert
short, specific, handlers to correct the interrupt vector addresses. In contrast to that in current design it is a
tendency to have one interrupt handler in OS, which next decides which handling functions should be invoked. This makes
the handler longer, so it can be hard to make inlining (e.g. for risk V in Linux the first step is to save
each of general purpose registers, so on the start we have already 32 instructions in handler)</p>
<p>Ideas from the paper:</p>
<ul class="simple">
<li><p>Pipelines don’t have to be flushed</p></li>
<li><p>Additional HW resources reserved for only privileged mode can allow to execute privileged instruction without boring
with stopping user space program</p></li>
<li><p>Interrupts and exceptions can be treated as branches and can be speculated</p></li>
</ul>
</div>
<div class="section" id="hardware-software-cost-analysis-of-interrupt-processing-strategies">
<h2>Hardware/software cost analysis of interrupt processing strategies:<a class="headerlink" href="#hardware-software-cost-analysis-of-interrupt-processing-strategies" title="Permalink to this heading"></a></h2>
<blockquote>
<div><p>Hardware/software cost analysis of interrupt processing strategies
Mansur H. Samadzadeh, Loai E. Garalnabi, 2001</p>
</div></blockquote>
<p>Present overview for all main structures to handle exceptions, so:</p>
<ul class="simple">
<li><p>Instruction Window</p></li>
<li><p>Checkpoint repair</p></li>
<li><p>History file</p></li>
<li><p>Reorder buffer</p></li>
<li><p>Future file</p></li>
</ul>
</div>
<div class="section" id="igpu-exception-support-and-speculative-execution-on-gpus">
<h2>iGPU: Exception Support and Speculative Execution on GPUs<a class="headerlink" href="#igpu-exception-support-and-speculative-execution-on-gpus" title="Permalink to this heading"></a></h2>
<blockquote>
<div><p>iGPU: Exception Support and Speculative Execution on GPUs Jaikrishnan Menon, Marc de Kruijf, Karthikeyan
Sankaralingam, 2012</p>
</div></blockquote>
<p>They try to introduce exceptions to GPU. To do that, they observe that:</p>
<ul class="simple">
<li><p>it is possible to find points where it is low number of live registers (e.g., boundaries of kernels)</p></li>
<li><p>GPU execution has no side effects, so it can be safely rewritten</p></li>
<li><p>GPU program can be recompiled in runtime</p></li>
</ul>
<p>They introduce to the GPU program regions and subregions. Regions are parts of code which start at the beginning and end
with a small number of live registers. Subregion is a part of a region which has short length (not more than 32
instructions). In each subregion there is no instruction which overrides the output of the instruction from the previous
subregion. Each subregion end is an instruction barrier.</p>
<p>Exceptions and interrupts are handled by restarting execution of warp from the beginning of region. Wrong speculation is
handled by restarting execution of current subregion. In case when there are two exceptions in region, code is
dynamically recompiled and split into two regions to prevent live-locks.</p>
</div>
<div class="section" id="efficient-exception-handling-support-for-gpus">
<h2>Efficient Exception Handling Support for GPUs<a class="headerlink" href="#efficient-exception-handling-support-for-gpus" title="Permalink to this heading"></a></h2>
<blockquote>
<div><p>Efficient Exception Handling Support for GPUs
Ivan Tanasic, Isaac Gelado, Marc Jorda, Eduard Ayguade, Nacho Navarro, 2017</p>
</div></blockquote>
<p>One more time it is analysed the problem of precise interrupts for GPU. They observe that the only problematic
instructions are those related to memory access. All other instructions are guaranteed to end successfully or they kill
the program. This time there is more hardware modification and there are presented three propositions:</p>
<ul class="simple">
<li><p>stall warp until previous global load is solved - on GPU it is not so problematic because usually there is a lot of
other warp which wait to be executed.</p></li>
<li><p>save instructions which can fail (global loads) to next reply them, input registers are not allowed to be
modified until this instruction don’t claim that it doesn’t fail</p></li>
<li><p>operand logging - replay queue + storing operations</p></li>
</ul>
</div>
<div class="section" id="others">
<h2>Others<a class="headerlink" href="#others" title="Permalink to this heading"></a></h2>
<blockquote>
<div><p>Reducing Exception Management Overhead with Software Restart Markers
Mark Jerome Hampton, 2008</p>
</div></blockquote>
<p>Mention a paper of Alli and Bailey [AB04] where there is no ROB. Instead of that in RAT there are FIFO-s which store
mapping between physical and logical registers and the age of instruction. If there is a need to raise an exception it
is checked if all younger instruction have already ended if not an exception wait for some cycles and repeat the check.</p>
</div>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this heading"></a></h2>
<p>GPU research don’t help us much, because the main assumption is that operations don’t cause side effects
except of communication with main memory by load/store instructions. From research about CPUs, it looks like,
there is a “canonical” implementation of ROB that can be eventually introduced some small improvements, but
there aren’t any very different procedures.</p>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../components/icache.html" class="btn btn-neutral float-left" title="Instruction Cache" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../api.html" class="btn btn-neutral float-right" title="API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Kuźnia Rdzeni, 2025.
      <span class="lastupdated">Last updated on 21:53 2025-06-17.
      </span></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>