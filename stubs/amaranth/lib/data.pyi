"""
This type stub file was generated by pyright.
"""

from abc import ABCMeta, abstractmethod
from collections.abc import Callable, Iterator, Mapping
from enum import Enum
from typing import Optional
from amaranth.hdl import *
from amaranth.hdl.ast import Assign, ShapeCastable, ValueCastable
from coreblocks.utils._typing import ShapeLike, ValueLike

__all__ = ["Field", "Layout", "StructLayout", "UnionLayout", "ArrayLayout", "FlexibleLayout", "View", "Struct", "Union"]
class Field:
    def __init__(self, shape: ShapeLike, offset: int) -> None:
        ...
    
    @property
    def shape(self) -> ShapeLike:
        ...
    
    @shape.setter
    def shape(self, shape: ShapeLike) -> None:
        ...
    
    @property
    def offset(self) -> int:
        ...
    
    @offset.setter
    def offset(self, offset: int) -> None:
        ...
    
    @property
    def width(self) -> int:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __repr__(self) -> str:
        ...
    


class Layout(ShapeCastable, metaclass=ABCMeta):
    @staticmethod
    def cast(obj: ShapeCastable) -> Layout:
        """Cast a shape-castable object to a layout."""
        ...
    
    @staticmethod
    def of(obj: View) -> ShapeCastable:
        """Extract the layout from a view."""
        ...
    
    @abstractmethod
    def __iter__(self) -> Iterator[tuple[int | str, Field]]:
        """Iterate the layout, yielding ``(key, field)`` pairs. Keys may be strings or integers."""
        ...
    
    @abstractmethod
    def __getitem__(self, key: int | str) -> Field:
        """Retrieve the :class:`Field` associated with the ``key``, or raise ``KeyError``."""
        ...
    
    size: int = ...

    def as_shape(self) -> Shape:
        """Convert the representation defined by the layout to an unsigned :class:`Shape`."""
        ...
    
    def __eq__(self, other) -> bool:
        """Compare the layout with another.

        Two layouts are equal if they have the same size and the same fields under the same names.
        The order of the fields is not considered.
        """
        ...
    


class StructLayout(Layout):
    def __init__(self, members: Mapping[str, ShapeLike]) -> None:
        ...
    
    @property
    def members(self) -> dict[str, ShapeLike]:
        ...
    
    @members.setter
    def members(self, members: Mapping[str, ShapeLike]) -> None:
        ...
    
    def __iter__(self) -> Iterator[tuple[str, Field]]:
        ...
    
    def __getitem__(self, key: str) -> Field:
        ...
    
    @property
    def size(self) -> int:
        ...
    
    def __repr__(self) -> str:
        ...
    


class UnionLayout(Layout):
    def __init__(self, members: Mapping[str, ShapeLike]) -> None:
        ...
    
    @property
    def members(self) -> dict[str, ShapeLike]:
        ...
    
    @members.setter
    def members(self, members: Mapping[str, ShapeLike]) -> None:
        ...
    
    def __iter__(self) -> Iterator[tuple[str, Field]]:
        ...
    
    def __getitem__(self, key: str) -> Field:
        ...
    
    @property
    def size(self) -> int:
        ...
    
    def __repr__(self) -> str:
        ...
    


class ArrayLayout(Layout):
    def __init__(self, elem_shape: ShapeLike, length: int) -> None:
        ...
    
    @property
    def elem_shape(self) -> ShapeLike:
        ...
    
    @elem_shape.setter
    def elem_shape(self, elem_shape: ShapeLike) -> None:
        ...
    
    @property
    def length(self) -> int:
        ...
    
    @length.setter
    def length(self, length: int) -> None:
        ...
    
    def __iter__(self) -> Iterator[tuple[int, Field]]:
        ...
    
    def __getitem__(self, key: int) -> Field:
        ...
    
    @property
    def size(self) -> int:
        ...
    
    def __repr__(self) -> str:
        ...
    


class FlexibleLayout(Layout):
    def __init__(self, size: int, fields: Mapping[int | str, Field]) -> None:
        ...
    
    @property
    def size(self) -> int:
        ...
    
    @size.setter
    def size(self, size: int) -> None:
        ...
    
    @property
    def fields(self) -> dict[int | str, Field]:
        ...
    
    @fields.setter
    def fields(self, fields: Mapping[int | str, Field]) -> None:
        ...
    
    def __iter__(self) -> Iterator[tuple[int | str, Field]]:
        ...
    
    def __getitem__(self, key: int | str) -> Field:
        ...
    
    def __repr__(self) -> str:
        ...
    


class View(ValueCastable):
    def __init__(self, layout: ShapeCastable, target: Optional[ValueLike] = ..., *, name: Optional[str] = ..., reset: Optional[int | Enum] = ..., reset_less: Optional[bool] = ..., attrs : Optional[dict] = ..., decoder: Optional[type[Enum] | Callable[[int], str]] = ..., src_loc_at=...) -> None:
        ...
    
    @ValueCastable.lowermethod
    def as_value(self) -> Value:
        ...
    
    def eq(self, other: ValueLike) -> Assign:
        ...
    
    def __getitem__(self, key: str | ValueLike) -> Value:
        ...
    
    def __getattr__(self, name: str) -> Value:
        ...
    


class _AggregateMeta(ShapeCastable, type):
    def __new__(metacls, name, bases, namespace, *, _layout_cls=..., **kwargs): # -> Self@_AggregateMeta:
        ...
    
    def as_shape(cls):
        ...
    


class _Aggregate(View, metaclass=_AggregateMeta):
    def __init__(self, target=..., *, name=..., reset=..., reset_less=..., attrs=..., decoder=..., src_loc_at=...) -> None:
        ...
    


class Struct(_Aggregate, _layout_cls=StructLayout):
    ...


class Union(_Aggregate, _layout_cls=UnionLayout):
    ...


