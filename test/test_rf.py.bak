import random
import queue
from collections import namedtuple
from typing import Callable, Optional, Iterable
from amaranth import *
from amaranth.back import verilog
from amaranth.sim import Simulator, Settle
from coreblocks.transactions import TransactionModule, TransactionContext
from coreblocks.transactions.lib import FIFO, ConnectTrans, AdapterTrans, Adapter
from coreblocks.scheduler import *
from coreblocks.rf import RegisterFile
from coreblocks.rat import FRAT
from coreblocks.layouts import SchedulerLayouts, RSLayouts
from coreblocks.genparams import GenParams
from coreblocks.reorder_buffer import ReorderBuffer
from .common import RecordIntDict, TestCaseWithSimulator, TestGen, TestbenchIO


class RFTestCircuit(Elaboratable):
    def __init__(self, gen_params: GenParams):
        self.gen_params = gen_params

    def elaborate(self, platform):
        m = Module()

        m.submodules.rf = self.rf = RegisterFile(gen_params=self.gen_params)

        m.submodules.read1 = self.read1 = TestbenchIO(AdapterTrans(rf.read1))
        m.submodules.read2 = self.read2 = TestbenchIO(AdapterTrans(rf.read2))
        m.submodules.write = self.write = TestbenchIO(AdapterTrans(rf.write))
        m.submodules.free = self.free = TestbenchIO(AdapterTrans(rf.free))

        return m


class RegState:
    def __init__(self, value, valid):
        self.value = value
        self.valid = valid


def TestRegisterFile(TestCaseWithSimulator):
    def setUp(self):
        self.gen_params = GenParams("rv32i")
        self.m = RFTestCircuit(gen_params)
        self.iterations = 500

    def test_randomized(self):
        def command_stream_process():
            entries = self.m.rf.entries
            RF_state = [RegState(0, 0) for _ in range(2**self.gen_params.phys_regs_bits)]
            RF_state[0].valid = 1

            self.assertEqual((yield from entries[0].reg_val), 0)
            self.assertEqual((yield from entries[0].valid), 1)

            for _ in range(self.iterations):
                cmds = random.sample([self.m.read1, self.m.read2, self.m.write, self.m.free], random.randint(0, 4))
                for cmd in cmds:
                    yield from cmd.call_init({})
                results = []
                for cmd in cmds:
                    results.append((yield from cmd.call_do()))

            self.assertEqual((yield from entries[0].reg_val), 0)
            self.assertEqual((yield from entries[0].valid), 1)

        with self.runSimulation(self.m) as sim:
            sim.add_sync_process(command_stream_process)
