#!/usr/bin/env python3

import subprocess
import os
import sys
import argparse

from amaranth.vendor.lattice_ice40 import LatticeICE40Platform
from amaranth.build import Resource, Attrs, Pins, Clock, Connector, Platform
from amaranth.build.run import LocalBuildProducts
from amaranth import Module, Elaboratable, Cat

__all__ = ["ICE40Platform"]


class TestElaboratable(Elaboratable):
    def __init__(self, gen_params):
        from coreblocks.genparams import GenParams

        self.gp: GenParams = gen_params

    def elaborate(self, platform: Platform):
        from coreblocks.core import Core
        from coreblocks.layouts import FetchLayouts
        from coreblocks.transactions import TransactionModule
        from coreblocks.transactions.lib import FIFO, AdapterTrans

        m = Module()
        tm = TransactionModule(m)

        self.fifo_in = FIFO(self.gp.get(FetchLayouts).raw_instr, 2)
        self.core = Core(gen_params=self.gp, get_raw_instr=self.fifo_in.read)
        self.reg_feed_in = AdapterTrans(self.core.free_rf_fifo.write)

        m.d.comb += self.reg_feed_in.en.eq(1)

        m.d.comb += self.reg_feed_in.data_in.eq(
            Cat((platform.request("data_in", pin_number).i) for pin_number in range(6))
        )
        m.d.comb += Cat((platform.request("data_out", pin_number).o) for pin_number in range(6)).eq(
            Cat(self.core.announcement.debug_signals())
        )

        m.submodules.fifo_in = self.fifo_in
        m.submodules.reg_feed_in = self.reg_feed_in
        m.submodules.c = self.core
        return tm


class ICE40Platform(LatticeICE40Platform):
    """Implementation of LatticeICE40Platform abstract class.

    This class configures Lattice ICE40 platform.
    Defines clock signal and frequency, reset signal and any additional needed resources.
    """

    # See the base platform class for which one to choose.
    # This affects options passed to the toolchain so that it compiles for the correct chip.
    device = "iCE40HX8K"
    package = "CT256"

    # This names the pins you want to use, and configuration options for each such pin.
    resources = [
        Resource("clk1", 0, Pins("J3", dir="i"), Clock(12e6), Attrs(GLOBAL=True, IO_STANDARD="SB_LVCMOS")),
        Resource("rst", 0, Pins("R9", dir="i"), Attrs(GLOBAL=True, IO_STANDARD="SB_LVCMOS")),
        Resource.family("data_in", 0, default_name="data_in", ios=[Pins("A16", dir="i")]),
        Resource.family("data_in", 1, default_name="data_in", ios=[Pins("A15", dir="i")]),
        Resource.family("data_in", 2, default_name="data_in", ios=[Pins("B13", dir="i")]),
        Resource.family("data_in", 3, default_name="data_in", ios=[Pins("B11", dir="i")]),
        Resource.family("data_in", 4, default_name="data_in", ios=[Pins("A10", dir="i")]),
        Resource.family("data_in", 5, default_name="data_in", ios=[Pins("A11", dir="i")]),
        Resource.family("data_out", 0, default_name="data_out", ios=[Pins("B15", dir="o")]),
        Resource.family("data_out", 1, default_name="data_out", ios=[Pins("B14", dir="o")]),
        Resource.family("data_out", 2, default_name="data_out", ios=[Pins("A7", dir="o")]),
        Resource.family("data_out", 3, default_name="data_out", ios=[Pins("B7", dir="o")]),
        Resource.family("data_out", 4, default_name="data_out", ios=[Pins("A6", dir="o")]),
        Resource.family("data_out", 5, default_name="data_out", ios=[Pins("A5", dir="o")]),
    ]

    # The name of the resource that is the clock for the default clock domain.
    default_clk = "clk1"
    # The name of the resource that is the reset for the default clock domain.
    default_rst = "rst"

    # It isn't obvious what purpose this serves.
    # It may have something to do with certain toolchains.
    connectors = [
        Connector(
            "j",
            1,  # J1
            "A16 -   A15 B15 B13 B14 -   -   B12 B11 "
            "A11 B10 A10 C9  -   -   A9  B9  B8  A7  "
            "B7  C7  -   -   A6  C6  B6  C5  A5  C4  "
            "-   -   B5  C3  B4  B3  A2  A1  -   -   ",
        ),
        Connector(
            "j",
            2,  # J2
            "-   -   -   R15 P16 P15 -   -   N16 M15 "
            "M16 L16 K15 K16 -   -   K14 J14 G14 F14 "
            "J15 H14 -   -   H16 G15 G16 F15 F16 E14 "
            "-   -   E16 D15 D16 D14 C16 B16 -   -   ",
        ),
        Connector(
            "j",
            3,  # J3
            "R16 -   T15 T16 T13 T14 -   -   N12 P13 "
            "N10 M11 T11 P10 -   -   T10 R10 P8  P9  "
            "T9  R9  -   -   T7  T8  T6  R6  T5  R5  "
            "-   -   R3  R4  R2  T3  T1  T2  -   -   ",
        ),
        Connector(
            "j",
            4,  # J4
            "-   -   -   R1  P1  P2  -   -   N3  N2  "
            "M2  M1  L3  L1  -   -   K3  K1  J2  J1  "
            "H2  J3  -   -   G2  H1  F2  G1  E2  F1  "
            "-   -   D1  D2  C1  C2  B1  B2  -   -   ",
        ),
    ]

    def toolchain_program(self, products: LocalBuildProducts, name: str):
        """This function is used to install given program on FPGA device connected via USB port.

        It will be executed if you specify `do_program=True` in `build` function.

        Args:
            products (LocalBuildProducts): Build files from synthesis
            name (str): Name of the program given in `build` function. Defaults to "top".
        """
        iceprog = os.environ.get("ICEPROG", "iceprog")
        with products.extract("{}.bin".format(name)) as bitstream_filename:
            subprocess.check_call([iceprog, "-S", bitstream_filename])


def synthesize(platform: str, build: bool):
    from coreblocks.genparams import GenParams

    gp = GenParams("rv32i", phys_regs_bits=6, rob_entries_bits=7)

    if platform == "ice40":
        ICE40Platform().build(TestElaboratable(gen_params=gp), do_program=build)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-p",
        "--platform",
        default="ice40",
        choices=["ice40"],
        help="Selects platform to synthesize circuit on. Default: ice40",
    )
    parser.add_argument(
        "-b",
        "--build",
        action="store_true",
        help="If specified, script will install program on connected FPGA platform",
    )

    args = parser.parse_args()

    synthesize(args.platform, args.build)


if __name__ == "__main__":
    parent = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    sys.path.insert(0, parent)
    main()
