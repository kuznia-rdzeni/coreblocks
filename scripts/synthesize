#!/usr/bin/env python3

import subprocess
import os
import sys
import argparse

from amaranth.vendor.lattice_ice40 import LatticeICE40Platform
from amaranth.build import Resource, Attrs, Pins, Clock, Platform
from amaranth.build.run import LocalBuildProducts
from amaranth import Module, Elaboratable, Cat

__all__ = ["ICE40Platform"]


class TestElaboratable(Elaboratable):
    def __init__(self, gen_params, io_pins: int, instr_mem: list[int] = []):
        from coreblocks.genparams import GenParams

        self.gp: GenParams = gen_params
        self.io_pins: int = io_pins
        self.instr_mem = instr_mem

    def elaborate(self, platform: Platform):
        from coreblocks.core import Core
        from coreblocks.layouts import FetchLayouts
        from coreblocks.transactions import TransactionModule
        from coreblocks.transactions.lib import FIFO, AdapterTrans
        from coreblocks.wishbone import WishboneMaster, WishboneMemorySlave, WishboneParameters

        m = Module()
        tm = TransactionModule(m)
        wb_params = WishboneParameters(data_width=32, addr_width=30)

        self.wb_master = WishboneMaster(wb_params=wb_params)
        self.wb_mem_slave = WishboneMemorySlave(wb_params=wb_params, width=32, depth=32, init=self.instr_mem)
        self.fifo_in = FIFO(self.gp.get(FetchLayouts).raw_instr, 2)
        self.core = Core(gen_params=self.gp, wb_master=self.wb_master)
        self.reg_feed_in = AdapterTrans(self.core.free_rf_fifo.write)

        m.d.comb += self.reg_feed_in.en.eq(1)
        m.d.comb += self.wb_master.wbMaster.connect(self.wb_mem_slave.bus)

        m.d.comb += self.reg_feed_in.data_in.eq(platform.request("data_in", 0).i)
        m.d.comb += Cat(platform.request("data_out", 0).o).eq(Cat(self.core.announcement.debug_signals()))

        m.submodules.wb_master = self.wb_master
        m.submodules.wb_mem_slave = self.wb_mem_slave
        m.submodules.fifo_in = self.fifo_in
        m.submodules.reg_feed_in = self.reg_feed_in
        m.submodules.c = self.core

        return tm


# Tutorial for synthesis in amaranth:
# https://github.com/RobertBaruch/amaranth-tutorial/blob/main/9_synthesis.md
class ICE40Platform(LatticeICE40Platform):
    """Implementation of LatticeICE40Platform abstract class.

    This class configures Lattice ICE40 platform.
    Defines clock signal and frequency, reset signal and any additional needed resources.
    """

    # See the base platform class for which one to choose.
    # This affects options passed to the toolchain so that it compiles for the correct chip.
    device = "iCE40HX8K"
    package = "CT256"

    # This names the pins you want to use, and configuration options for each such pin.
    resources = [
        Resource("clk", 0, Pins("J3", dir="i"), Clock(12e6), Attrs(GLOBAL=True, IO_STANDARD="SB_LVCMOS")),
        Resource("rst", 0, Pins("R9", dir="i"), Attrs(GLOBAL=True, IO_STANDARD="SB_LVCMOS")),
        Resource("data_in", 0, Pins("A16 A15 B13 B11 A10 A11", dir="i")),
        Resource("data_out", 0, Pins("B15 B14 A7 B7 A6 A5", dir="o")),
    ]

    # The name of the resource that is the clock for the default clock domain.
    default_clk = "clk"
    # The name of the resource that is the reset for the default clock domain.
    default_rst = "rst"

    # It isn't obvious what purpose this serves.
    # It may have something to do with certain toolchains.
    connectors = []

    def toolchain_program(self, products: LocalBuildProducts, name: str):
        """This function is used to install given program on FPGA device connected via USB port.

        It will be executed if you specify `do_program=True` in `build` function.

        Args:
            products (LocalBuildProducts): Build files from synthesis
            name (str): Name of the program given in `build` function. Defaults to "top".
        """
        iceprog = os.environ.get("ICEPROG", "iceprog")
        with products.extract("{}.bin".format(name)) as bitstream_filename:
            subprocess.check_call([iceprog, "-S", bitstream_filename])


def synthesize(platform: str, build: bool):
    from coreblocks.genparams import GenParams

    gp = GenParams("rv32i", phys_regs_bits=6, rob_entries_bits=7)

    if platform == "ice40":
        ICE40Platform().build(TestElaboratable(gen_params=gp, io_pins=6), do_program=build)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-p",
        "--platform",
        default="ice40",
        choices=["ice40"],
        help="Selects platform to synthesize circuit on. Default: ice40",
    )
    parser.add_argument(
        "-b",
        "--build",
        action="store_true",
        help="If specified, script will install program on connected FPGA platform",
    )

    args = parser.parse_args()

    synthesize(args.platform, args.build)


if __name__ == "__main__":
    parent = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    sys.path.insert(0, parent)
    main()
