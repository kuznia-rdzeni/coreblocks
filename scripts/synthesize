#!/usr/bin/env python3

import subprocess
import os
import sys
import argparse

from amaranth.vendor.lattice_ice40 import LatticeICE40Platform
from amaranth.vendor.lattice_ecp5 import LatticeECP5Platform
from amaranth.build import Resource, Attrs, Pins, Clock, Platform, PinsN
from amaranth.build.run import LocalBuildProducts
from amaranth import Module, Elaboratable, Cat

__all__ = ["ICE40Platform", "ECP5Platform"]


class TestElaboratable(Elaboratable):
    def __init__(self, gen_params, io_pins: int, instr_mem: list[int] = []):
        from coreblocks.genparams import GenParams

        self.gp: GenParams = gen_params
        self.io_pins: int = io_pins
        self.instr_mem = instr_mem

    def elaborate(self, platform: Platform):
        from coreblocks.core import Core
        from coreblocks.layouts import FetchLayouts
        from coreblocks.transactions import TransactionModule
        from coreblocks.transactions.lib import FIFO, AdapterTrans
        from coreblocks.wishbone import WishboneMaster, WishboneMemorySlave, WishboneParameters

        m = Module()
        tm = TransactionModule(m)
        wb_params = WishboneParameters(data_width=32, addr_width=30)

        self.wb_master = WishboneMaster(wb_params=wb_params)
        self.wb_mem_slave = WishboneMemorySlave(wb_params=wb_params, width=32, depth=32, init=self.instr_mem)
        self.fifo_in = FIFO(self.gp.get(FetchLayouts).raw_instr, 2)
        self.core = Core(gen_params=self.gp, wb_master=self.wb_master)
        self.reg_feed_in = AdapterTrans(self.core.free_rf_fifo.write)

        m.d.comb += self.reg_feed_in.en.eq(1)
        m.d.comb += self.wb_master.wbMaster.connect(self.wb_mem_slave.bus)

        m.d.comb += self.reg_feed_in.data_in.eq(platform.request("data_in", 0).i)
        m.d.comb += Cat(platform.request("data_out", 0).o).eq(Cat(self.core.announcement.debug_signals()))

        m.submodules.wb_master = self.wb_master
        m.submodules.wb_mem_slave = self.wb_mem_slave
        m.submodules.fifo_in = self.fifo_in
        m.submodules.reg_feed_in = self.reg_feed_in
        m.submodules.c = self.core

        return tm


# Tutorial for synthesis in amaranth:
# https://github.com/RobertBaruch/amaranth-tutorial/blob/main/9_synthesis.md
class ICE40Platform(LatticeICE40Platform):
    """Implementation of LatticeICE40Platform abstract class.

    This class configures Lattice ICE40 platform.
    Defines clock signal and frequency, reset signal and any additional needed resources.
    """

    # See the base platform class for which one to choose.
    # This affects options passed to the toolchain so that it compiles for the correct chip.
    device = "iCE40HX8K"
    package = "CT256"

    # This names the pins you want to use, and configuration options for each such pin.
    resources = [
        Resource("clk", 0, Pins("J3", dir="i"), Clock(12e6), Attrs(GLOBAL=True, IO_STANDARD="SB_LVCMOS")),
        Resource("rst", 0, Pins("R9", dir="i"), Attrs(GLOBAL=True, IO_STANDARD="SB_LVCMOS")),
        Resource("data_in", 0, Pins("A16 A15 B13 B11 A10 A11", dir="i")),
        Resource(
            "data_out",
            0,
            Pins(
                """
                                     C14 B15 D13 B14 C12 E11 C13 E10 C11 D11
                                     B12 B10 C10 D10 C9  E9  D9  F9  D8  B8
                                     A7  C7  B7  B6  C6  D7  A6  D6  A5  B5
                                     E6  B4  A2  D5  A1  C5  C4  B3  D4  E5
                                     D3  C3  P16 M13 M14 L12 N16
                                     """,
                dir="o",
            ),
        ),
    ]

    # The name of the resource that is the clock for the default clock domain.
    default_clk = "clk"
    # The name of the resource that is the reset for the default clock domain.
    default_rst = "rst"

    # It isn't obvious what purpose this serves.
    # It may have something to do with certain toolchains.
    connectors = []

    def toolchain_program(self, products: LocalBuildProducts, name: str):
        """This function is used to install given program on FPGA device connected via USB port.

        It will be executed if you specify `do_program=True` in `build` function.

        Args:
            products (LocalBuildProducts): Build files from synthesis
            name (str): Name of the program given in `build` function. Defaults to "top".
        """
        iceprog = os.environ.get("ICEPROG", "iceprog")
        with products.extract("{}.bin".format(name)) as bitstream_filename:
            subprocess.check_call([iceprog, "-S", bitstream_filename])


class ECP5Platform(LatticeECP5Platform):
    device = "LFE5UM5G-85F"
    package = "BG381"
    speed = "8"
    default_clk = "clk"
    default_rst = "rst"

    def __init__(self, *, VCCIO1="2V5", VCCIO6="3V3", **kwargs):
        """
        VCCIO1 is connected by default to 2.5 V via R100 (can be set to 3.3 V by disconnecting
        R100 and connecting R105)
        VCCIO6 is connected to 3.3 V by default via R99 (can be switched to 2.5 V with R104,
        see page 51 in the ECP5-5G-EVN datasheet)
        """
        super().__init__(**kwargs)
        assert VCCIO1 in ("3V3", "2V5")
        assert VCCIO6 in ("3V3", "2V5")
        self._VCCIO1 = VCCIO1
        self._VCCIO6 = VCCIO6

    resources = [
        Resource("rst", 0, PinsN("G2", dir="i"), Attrs(IO_TYPE="LVCMOS33")),
        Resource("clk", 0, Pins("A10", dir="i"), Clock(12e6), Attrs(IO_TYPE="LVCMOS33")),
        Resource("data_in", 0, Pins("M5 M4 N4 N5 P5 N3", dir="i")),
        Resource(
            "data_out",
            0,
            Pins(
                """
                    A4 A5 B5 C5 C4 A3 B4 B3 E4 C3
                    D5 D3 F4 E5 E3 F5 A2 B2 B1 C2
                    C1 D2 D1 E1 H4 H5 G5 H3 G3 F2
                    F3 E2 G2 H2 F1 G1 J4 J3 J5 K3
                    K2 H1 J1 K1 K4 L4 K5
                """,
                dir="o",
            ),
        ),
    ]

    connectors = []

    def toolchain_program(self, products, name):
        openocd = os.environ.get("OPENOCD", "openocd")
        with products.extract("{}-openocd.cfg".format(name), "{}.svf".format(name)) as (
            config_filename,
            vector_filename,
        ):
            subprocess.check_call(
                [
                    openocd,
                    "-f",
                    config_filename,
                    "-c",
                    "transport select jtag; init; svf -quiet {}; exit".format(vector_filename),
                ]
            )


def synthesize(platform: str, build: bool):
    from coreblocks.genparams import GenParams

    gp = GenParams("rv32i", phys_regs_bits=6, rob_entries_bits=7)

    if platform == "ice40":
        ICE40Platform().build(TestElaboratable(gen_params=gp, io_pins=6), do_program=build)
    elif platform == "ecp5":
        ECP5Platform().build(TestElaboratable(gen_params=gp, io_pins=6), do_program=build)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-p",
        "--platform",
        default="ecp5",
        choices=["ice40", "ecp5"],
        help="Selects platform to synthesize circuit on. Default: ecp5",
    )
    parser.add_argument(
        "-b",
        "--build",
        action="store_true",
        help="If specified, script will install program on connected FPGA platform",
    )

    args = parser.parse_args()

    synthesize(args.platform, args.build)


if __name__ == "__main__":
    parent = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    sys.path.insert(0, parent)
    main()
